<!DOCTYPE html>
<html>
<head>
    <title>宇宙探索者</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #infoPanel { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; }
        #resourcePanel { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; }
    </style>
</head>
<body>
    <div id="infoPanel">
        <p>WASD: 移动 | 空格: 跳跃 | E: 收集资源 | 1: 建造基地模块</p>
        <p id="planetInfo">当前星球: 未知星球</p>
    </div>
    <div id="resourcePanel">
        <p>能源: <span id="energy">0</span></p>
        <p>矿石: <span id="ore">0</span></p>
        <p>基地模块: <span id="modules">0</span></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r181/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r181/controls/PointerLockControls.js"></script>
    <script>
        // 游戏状态
        const gameState = {
            resources: {
                energy: 0,
                ore: 0,
                modules: 0
            },
            currentPlanet: "未知星球",
            baseModules: []
        };

        // 初始化场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);

        // 相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6;

        // 渲染器
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // 星空背景
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 10000;
            const positions = new Float32Array(starsCount * 3);
            
            for (let i = 0; i < starsCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 2000;
                positions[i3 + 1] = (Math.random() - 0.5) * 2000;
                positions[i3 + 2] = (Math.random() - 0.5) * 2000;
            }
            
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        // 创建星球表面
        function createPlanet() {
            // 地面
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333355,
                wireframe: false
            });
            
            // 添加地形起伏
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 2;
            }
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // 资源点
            createResources();
        }

        // 创建资源点
        function createResources() {
            const resourceGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            
            // 能源资源
            for (let i = 0; i < 10; i++) {
                const resource = new THREE.Mesh(
                    resourceGeometry,
                    new THREE.MeshBasicMaterial({ color: 0x00ffff })
                );
                resource.position.set(
                    (Math.random() - 0.5) * 100,
                    0.5,
                    (Math.random() - 0.5) * 100
                );
                resource.userData.type = 'energy';
                scene.add(resource);
            }
            
            // 矿石资源
            for (let i = 0; i < 10; i++) {
                const resource = new THREE.Mesh(
                    resourceGeometry,
                    new THREE.MeshBasicMaterial({ color: 0xffaa00 })
                );
                resource.position.set(
                    (Math.random() - 0.5) * 100,
                    0.5,
                    (Math.random() - 0.5) * 100
                );
                resource.userData.type = 'ore';
                scene.add(resource);
            }
        }

        // 控制器
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.body.addEventListener('click', () => controls.lock());

        // 移动控制
        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = false;

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': if (canJump) velocity.y += 5; canJump = false; break;
                case 'KeyE': collectResource(); break;
                case 'Digit1': buildModule(); break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        });

        // 资源收集
        function collectResource() {
            const raycaster = new THREE.Raycaster();
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);
            
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0 && intersects[0].distance < 5) {
                const target = intersects[0].object;
                if (target.userData.type) {
                    gameState.resources[target.userData.type]++;
                    updateResourceDisplay();
                    scene.remove(target);
                }
            }
        }

        // 建造基地模块
        function buildModule() {
            if (gameState.resources.ore >= 5 && gameState.resources.energy >= 3) {
                gameState.resources.ore -= 5;
                gameState.resources.energy -= 3;
                gameState.resources.modules++;
                
                const module = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshPhongMaterial({ color: 0x00ff00 })
                );
                
                // 在玩家前方生成
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.multiplyScalar(5);
                module.position.copy(camera.position).add(forward);
                module.position.y = 1;
                
                scene.add(module);
                gameState.baseModules.push(module);
                updateResourceDisplay();
            }
        }

        // 更新资源显示
        function updateResourceDisplay() {
            document.getElementById('energy').textContent = gameState.resources.energy;
            document.getElementById('ore').textContent = gameState.resources.ore;
            document.getElementById('modules').textContent = gameState.resources.modules;
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 移动逻辑
            velocity.x -= velocity.x * 10.0 * 0.016;
            velocity.z -= velocity.z * 10.0 * 0.016;
            velocity.y -= 9.8 * 0.016; // 重力

            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.normalize();

            if (moveState.forward || moveState.backward) velocity.z -= direction.z * 20.0 * 0.016;
            if (moveState.left || moveState.right) velocity.x -= direction.x * 20.0 * 0.016;

            controls.moveRight(-velocity.x * 0.016);
            controls.moveForward(-velocity.z * 0.016);
            controls.getObject().position.y += velocity.y * 0.016;

            // 地面碰撞检测
            if (controls.getObject().position.y < 1.6) {
                velocity.y = 0;
                controls.getObject().position.y = 1.6;
                canJump = true;
            }

            renderer.render(scene, camera);
        }

        // 初始化
        createStars();
        createPlanet();
        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
