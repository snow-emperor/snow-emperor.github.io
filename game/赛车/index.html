<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çº¯å‰ç«¯èµ›è½¦ç«é€Ÿ (P2P + AI)</title>
    
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        /* ------------------- å¸ƒå±€ä¸å®¹å™¨ ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px 10px;
            background-color: #f0f4f8;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #333;
        }
        #app-container {
            width: 100%;
            max-width: 960px;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        h1 {
            color: #007bff;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 25px;
            text-align: center;
        }
        
        /* æ¨¡å—å®¹å™¨æ ·å¼ */
        #player-status, #garage, #race-status, #mode-selection, #controls {
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background-color: #f9f9fc;
        }
        
        /* åŠ¨æ€éšè—ç±» */
        #controls.hidden { display: none; }
        .peer-info { display: block; }
        .peer-info.hidden { display: none; }

        /* ------------------- æŒ‰é’®ä¸è¾“å…¥ ------------------- */
        button {
            padding: 10px 18px;
            margin: 5px 5px 5px 0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            font-weight: 600;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        button:hover:not(:disabled) { background-color: #0056b3; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }

        /* çŠ¶æ€å¾½ç«  */
        .status-badge { padding: 5px 10px; border-radius: 4px; font-weight: bold; }
        .status-connected { background-color: #d4edda; color: #155724; }
        .status-disconnected { background-color: #f8d7da; color: #721c24; }
        
        /* ------------------- æ¸¸æˆç”»å¸ƒä¸æ—¥å¿— ------------------- */
        #game-canvas {
            border: 3px solid #333;
            background-color: #eee;
            display: block;
            width: 800px; 
            height: 400px;
            margin: 15px auto 10px;
            border-radius: 5px;
        }
        #game-status-log {
            padding: 10px;
            background-color: #fff0d9;
            border: 1px solid #ffcc66;
            border-radius: 4px;
        }
        
        /* ------------------- ç§»åŠ¨ç«¯æ“æ§ ------------------- */
        #mobile-controls { 
            text-align: center; 
            padding-top: 20px;
            border-top: 1px dashed #ccc;
            margin-top: 20px;
        }
        .mobile-button {
            display: inline-block;
            padding: 15px 30px;
            margin: 8px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            user-select: none;
        }
        .mobile-button:active { background-color: #0056b3; }
        .steering { width: 100px; }

        @media (max-width: 840px) {
            #game-canvas {
                width: 100%; 
                height: 50vw;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1>ğŸï¸ çº¯å‰ç«¯èµ›è½¦ç«é€Ÿ P2P & AI</h1>

        <div id="mode-selection">
            <h2>ğŸ•¹ï¸ æ¸¸æˆæ¨¡å¼é€‰æ‹©</h2>
            <p>å½“å‰æ¨¡å¼: <strong id="current-mode-display">å¤šäººè”æœº (P2P)</strong></p>
            <button onclick="window.game.toggleSinglePlayer(true)" id="btn-single-player">åˆ‡æ¢åˆ°å•æœºäººæœºæ¨¡å¼ (Bot)</button>
            <button onclick="window.game.toggleSinglePlayer(false)" id="btn-multiplayer" disabled>åˆ‡æ¢åˆ°å¤šäººè”æœºæ¨¡å¼ (P2P)</button>
        </div>

        <div id="player-status">
            <h2>ğŸ’° ç©å®¶æ•°æ®</h2>
            <p>å½“å‰ä½™é¢: <strong id="credits-display">0</strong></p>
            <p>è½¦è¾†é…ç½®: <strong id="car-config-display">æœªåŠ è½½</strong></p>
            <button onclick="window.game.saveTestData()">åˆå§‹åŒ–/é‡ç½®æµ‹è¯•æ•°æ®</button>
        </div>

        <div id="garage">
            <h2>ğŸ› ï¸ æˆ‘çš„è½¦åº“ä¸æ”¹è£…</h2>
            <div id="modification-options">
                <div style="border: 1px solid #ccc; padding: 10px; margin-top: 10px;">
                    <h4>å¼•æ“ (Engine)</h4>
                    <p>åŠ é€Ÿæ€§èƒ½: <strong id="current-engine-perf">...</strong> (Lv.<span id="current-engine-level">1</span>)</p>
                    <button onclick="window.game.upgradePart('engine')" id="engine-upgrade-button">
                        å‡çº§ (Lv.<span id="next-engine-level">2</span>) (èŠ±è´¹: <span id="engine-upgrade-cost">1000</span>)
                    </button>
                </div>
                
                <div style="border: 1px solid #ccc; padding: 10px; margin-top: 10px;">
                    <h4>è½®èƒ (Tires)</h4>
                    <p>æ“æ§æ€§èƒ½: <strong id="current-tire-perf">...</strong> (Lv.<span id="current-tire-level">1</span>)</p>
                    <button onclick="window.game.upgradePart('tires')" id="tires-upgrade-button">
                        å‡çº§ (Lv.<span id="next-tire-level">2</span>) (èŠ±è´¹: <span id="tires-upgrade-cost">500</span>)
                    </button>
                </div>
                <p id="upgrade-message" style="color: red; margin-top: 10px;"></p>
            </div>
        </div>

        <div id="controls">
            <h2>ğŸ”— PeerJS è”æœºæ§åˆ¶</h2>
            <div id="peer-connection-info" class="peer-info">
                <p>æ‚¨çš„ Peer ID: <strong id="my-peer-id" class="status-disconnected">...</strong></p>
                <p>è¿æ¥çŠ¶æ€: <span id="connection-status" class="status-disconnected">æ–­å¼€</span></p>

                <label for="remote-id">è¿æ¥åˆ°è¿œç«¯ ID:</label>
                <input type="text" id="remote-id" placeholder="è¾“å…¥å¯¹æ–¹çš„ Peer ID">
                <button onclick="window.game.connectToPeer()">è¿æ¥</button>
                <hr>
            </div>

            <div id="peer-message-box" class="peer-info">
                <h3>P2P æ¶ˆæ¯æµ‹è¯•</h3>
                <input type="text" id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯">
                <button onclick="window.game.sendMessage()">å‘é€æ•°æ®åŒ…</button>
                <div id="messages-log"></div>
            </div>
        </div>
        
        <div id="race-status">
            <h2>ğŸ æ¯”èµ›çŠ¶æ€</h2>
            <p>æ¯”èµ›çŠ¶æ€: <strong id="race-active-status">æœªå¼€å§‹</strong></p>
            <p>æˆ‘çš„åœˆæ•°: <strong id="my-lap-count">0 / 3</strong> (æœ€è¿‘æ£€æŸ¥ç‚¹: <span id="my-checkpoint">å‡†å¤‡åŒº</span>)</p>
            <p><span id="remote-player-label">å¯¹æ‰‹</span>åœˆæ•°: <strong id="remote-lap-count">N/A</strong> / 3</p>
            <button onclick="window.game.startRace()" id="start-race-button">å¼€å§‹æ¯”èµ›</button>
        </div>
        
        <div id="game-container">
            <h2>ğŸ® æ¸¸æˆç”»å¸ƒ</h2>
            <canvas id="game-canvas" width="800" height="400"></canvas>
            <p><span id="game-status-label">P2P åŒæ­¥çŠ¶æ€ / æ¯”èµ›æ—¥å¿—:</span></p>
            <div id="game-status-log"></div>
        </div>

        <div id="mobile-controls">
            <h2>ğŸ“± ç§»åŠ¨ç«¯æ“æ§</h2>
            <div>
                <div id="btn-up" class="mobile-button">â¬†ï¸ åŠ é€Ÿ (W)</div>
                <div id="btn-down" class="mobile-button">â¬‡ï¸ åˆ¹è½¦ (S)</div>
            </div>
            <div style="margin-top: 10px;">
                <div id="btn-left" class="mobile-button steering">â¬…ï¸ å·¦è½¬ (A)</div>
                <div id="btn-right" class="mobile-button steering">â¡ï¸ å³è½¬ (D)</div>
            </div>
        </div>
    </div>

    <script>
        // --- Matter.js æ¨¡å—è§£æ„ ---
        const { Engine, Render, Runner, World, Bodies, Events, Body, Vector } = Matter;

        // --- é…ç½®æ¨¡å— (Config) ---
        const CAR_CONFIG = {
            MAX_LAPS: 3, MAX_SPEED: 5,
            engine: { baseForce: 0.001, maxLevel: 5, getCost: (level) => level * 1000, getForce: (level) => 0.001 + (level * 0.0005) },
            tires: { baseSteering: 0.02, maxLevel: 5, getCost: (level) => level * 500, getSteering: (level) => 0.02 + (level * 0.01) }
        };

        const CHECKPOINTS = [
            { x: 100, y: 350, w: 10, h: 50, label: 'CP1' }, { x: 700, y: 350, w: 10, h: 50, label: 'CP2' }, 
            { x: 700, y: 50, w: 10, h: 50, label: 'CP3' }, { x: 100, y: 50, w: 50, h: 10, label: 'Finish Line' } 
        ];

        const initialRaceState = { lap: 0, nextCheckpoint: 1, finished: false, finishTime: null, label: 'Ready' };
        const defaultPlayerData = { credits: 0, cars: [{ name: "Starter Car", engineLevel: 1, tireLevel: 1 }] };

        // --- ç‰©ç†æ¨¡å— (Physics) å†…éƒ¨å˜é‡ ---
        let engine, render, runner, world;
        let myCar, remoteCar;
        const WIDTH = 800;
        const HEIGHT = 400;

        const KEY_STATE = { UP: false, DOWN: false, LEFT: false, RIGHT: false };
        let ACCELERATION_FORCE = 0.001; 
        let STEERING_SPEED = 0.02;      

        // --- ä¸»æ¨¡å— (Main) å†…éƒ¨å˜é‡ ---
        const LOCAL_STORAGE_KEY = 'racingGamePlayerProfile';
        const MAX_LAPS = CAR_CONFIG.MAX_LAPS;

        let peer;
        let connection;
        let playerData = { ...defaultPlayerData };

        let raceActive = false;
        let isHost = false; 
        let myRaceState = { ...initialRaceState };
        let remoteRaceState = { ...initialRaceState };
        
        // --- æ¸¸æˆæ¨¡å¼çŠ¶æ€ ---
        let isSinglePlayerMode = false;
        let botInterval; 
        const BOT_ACCELERATION = 0.001;
        const BOT_MAX_SPEED = 3.5; 

        
        // ===================================
        // ======= ç‰©ç†æ ¸å¿ƒåŠŸèƒ½ (PHYSICS) ======
        // ===================================

        function createCar(x, y, color, label) {
            return Bodies.rectangle(x, y, 40, 20, {
                label: label,
                frictionAir: 0.1, mass: 5, inertia: Infinity, 
                render: { fillStyle: color, strokeStyle: '#000000', lineWidth: 1 }
            });
        }

        function initPhysics(playerCarConfig) {
            const canvas = document.getElementById('game-canvas');
            if (!canvas) return;

            engine = Engine.create();
            world = engine.world;
            world.gravity.y = 0; 
            
            render = Render.create({ canvas: canvas, engine: engine, options: { width: WIDTH, height: HEIGHT, wireframes: false, background: '#eeeeee' } });

            const walls = [
                Bodies.rectangle(WIDTH / 2, 0, WIDTH, 20, { isStatic: true, label: 'Wall' }),
                Bodies.rectangle(WIDTH / 2, HEIGHT, WIDTH, 20, { isStatic: true, label: 'Wall' }),
                Bodies.rectangle(0, HEIGHT / 2, 20, HEIGHT, { isStatic: true, label: 'Wall' }),
                Bodies.rectangle(WIDTH, HEIGHT / 2, 20, HEIGHT, { isStatic: true, label: 'Wall' }),
                Bodies.rectangle(400, 200, 400, 200, { isStatic: true, label: 'Inner Wall', render: { fillStyle: '#999999' } })
            ];
            World.add(world, walls);
            
            CHECKPOINTS.forEach((cp, index) => {
                let body = Bodies.rectangle(cp.x, cp.y, cp.w, cp.h, { 
                    isStatic: true, isSensor: true, label: cp.label,
                    render: { fillStyle: cp.label === 'Finish Line' ? '#00FF00' : '#FFFF00', opacity: 0.5 } 
                });
                body.index = index + 1; 
                World.add(world, body);
            });

            myCar = createCar(100, 150, 'blue', 'MyCar');
            World.add(world, myCar);
            updatePhysicsParameters(playerData.cars[0]); 
            
            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'collisionStart', handleCollision); 
        }

        function updatePhysicsParameters(carConfig) {
            ACCELERATION_FORCE = CAR_CONFIG.engine.getForce(carConfig.engineLevel);
            STEERING_SPEED = CAR_CONFIG.tires.getSteering(carConfig.tireLevel);
        }

        Events.on(engine, 'beforeUpdate', () => {
            if (!myCar) return;

            const velocity = myCar.velocity;
            const speed = Vector.magnitude(velocity);
            const direction = myCar.angle;

            // 1. åŠ é€Ÿ/å‡é€Ÿ
            if (KEY_STATE.UP) {
                const force = Vector.create(ACCELERATION_FORCE * Math.cos(direction), ACCELERATION_FORCE * Math.sin(direction));
                Body.applyForce(myCar, myCar.position, force);
            } else if (KEY_STATE.DOWN) {
                const force = Vector.create(-ACCELERATION_FORCE * 0.5 * Math.cos(direction), -ACCELERATION_FORCE * 0.5 * Math.sin(direction));
                Body.applyForce(myCar, myCar.position, force);
            }

            // 2. è½¬å‘
            if (KEY_STATE.LEFT) {
                Body.setAngularVelocity(myCar, myCar.angularVelocity - STEERING_SPEED * (speed / CAR_CONFIG.MAX_SPEED)); 
            } else if (KEY_STATE.RIGHT) {
                Body.setAngularVelocity(myCar, myCar.angularVelocity + STEERING_SPEED * (speed / CAR_CONFIG.MAX_SPEED));
            }

            // 3. é™åˆ¶é€Ÿåº¦
            if (speed > CAR_CONFIG.MAX_SPEED) {
                const newVelocity = Vector.mult(Vector.normalise(velocity), CAR_CONFIG.MAX_SPEED);
                Body.setVelocity(myCar, newVelocity);
            }
        });
        
        function addRemoteCar(x, y) {
            if (!world || remoteCar) return;
            remoteCar = createCar(x, y, 'red', 'RemoteCar');
            World.add(world, remoteCar);
            if (isSinglePlayerMode) Body.setPosition(remoteCar, { x: 100, y: 120 });
        }

        function updateRemoteCar(x, y, angle) {
            if (!remoteCar) return;
            Body.setPosition(remoteCar, { x: x, y: y });
            Body.setAngle(remoteCar, angle);
        }

        function removeRemoteCar() {
            if (world && remoteCar) {
                World.remove(world, remoteCar);
                remoteCar = null;
            }
        }
        
        function getMyCar() { return myCar; }

        // --- AI é€»è¾‘ (BOT) ---

        function runBotLogic() {
            if (!remoteCar || !raceActive || !isSinglePlayerMode) return;

            const currentTargetIndex = remoteRaceState.nextCheckpoint - 1; 
            const targetCP = CHECKPOINTS[currentTargetIndex];
            
            if (!targetCP) return;

            const targetPos = Vector.create(targetCP.x, targetCP.y);
            const botPos = remoteCar.position;
            const diffVector = Vector.sub(targetPos, botPos);
            const targetAngle = Math.atan2(diffVector.y, diffVector.x);
            let currentAngle = remoteCar.angle;
            let angleDiff = targetAngle - currentAngle;

            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            const force = Vector.create(BOT_ACCELERATION * Math.cos(currentAngle), BOT_ACCELERATION * Math.sin(currentAngle));
            Body.applyForce(remoteCar, botPos, force);
            
            const BOT_STEERING_FACTOR = 0.006; 
            if (Math.abs(angleDiff) > 0.05) { 
                if (angleDiff > 0) {
                    Body.setAngularVelocity(remoteCar, remoteCar.angularVelocity + BOT_STEERING_FACTOR);
                } else {
                    Body.setAngularVelocity(remoteCar, remoteCar.angularVelocity - BOT_STEERING_FACTOR);
                }
            } else {
                 Body.setAngularVelocity(remoteCar, remoteCar.angularVelocity * 0.9); 
            }
            
            const speed = Vector.magnitude(remoteCar.velocity);
            if (speed > BOT_MAX_SPEED) {
                const newVelocity = Vector.mult(Vector.normalise(remoteCar.velocity), BOT_MAX_SPEED);
                Body.setVelocity(remoteCar, newVelocity);
            }

            if (Vector.magnitude(diffVector) < 40) {
                const checkpointBody = CHECKPOINTS[currentTargetIndex];
                if (checkpointBody) {
                    if (checkpointBody.label === 'Finish Line' && remoteRaceState.nextCheckpoint === CHECKPOINTS.length) { 
                        remoteRaceState.lap++;
                        remoteRaceState.nextCheckpoint = 1; 
                    } else if (checkpointBody.label !== 'Finish Line') {
                        remoteRaceState.nextCheckpoint++;
                    }
                    
                    remoteRaceState.label = checkpointBody.label;
                    updateRaceUI();
                    
                    if (remoteRaceState.lap >= MAX_LAPS) {
                        finishRace(false); 
                    }
                }
            }
            
            document.getElementById('game-status-log').innerHTML = `**[AI çŠ¶æ€]** ç›®æ ‡: ${remoteRaceState.label}, é€Ÿåº¦: ${speed.toFixed(2)}`;
        }


        // ===================================
        // ======= ä¸»æ¸¸æˆåŠŸèƒ½ (MAIN) ============
        // ===================================

        // --- æ•°æ®æŒä¹…åŒ–ä¸ UI ---

        function loadPlayerData() {
            const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (storedData) {
                try { playerData = JSON.parse(storedData); } catch (e) { playerData = { ...defaultPlayerData }; }
            }
            updateUI(); 
            // é»˜è®¤å¯åŠ¨ä¸ºå¤šäººæ¨¡å¼ï¼Œå¹¶æ‰§è¡Œ UI éšè—é€»è¾‘
            window.game.toggleSinglePlayer(false); 
        }

        function savePlayerData() {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(playerData));
            updateUI();
        }

        window.game.saveTestData = function() {
            playerData = { credits: 5000, cars: [{ name: "Test Racer 9000", engineLevel: 3, tireLevel: 2 }] };
            savePlayerData();
        }

        window.game.addCredits = function(amount) {
            playerData.credits += amount;
            savePlayerData();
        }

        function updateUI() {
            document.getElementById('credits-display').innerText = playerData.credits;
            const car = playerData.cars[0];
            document.getElementById('car-config-display').innerText = 
                `å¼•æ“: Lv.${car.engineLevel}, è½®èƒ: Lv.${car.tireLevel}`;
                
            updateGarageUI(car);
            if (myCar) updatePhysicsParameters(car);
            updateRaceUI();
        }

        function updateGarageUI(car) {
            const engineLevel = car.engineLevel;
            const engineConfig = CAR_CONFIG.engine;
            document.getElementById('current-engine-level').innerText = engineLevel;
            document.getElementById('current-engine-perf').innerText = engineConfig.getForce(engineLevel).toFixed(5);
            
            const nextEngineLevel = engineLevel + 1;
            const btn = document.getElementById('engine-upgrade-button');
            if (engineLevel < engineConfig.maxLevel) {
                btn.innerText = `å‡çº§ (Lv.${nextEngineLevel}) (èŠ±è´¹: ${engineConfig.getCost(nextEngineLevel)})`;
                btn.disabled = false;
            } else {
                btn.innerText = "å·²è¾¾æœ€é«˜ç­‰çº§";
                btn.disabled = true;
            }

            const tireLevel = car.tireLevel;
            const tireConfig = CAR_CONFIG.tires;
            const btnTire = document.getElementById('tires-upgrade-button');
            const nextTireLevel = tireLevel + 1;
            document.getElementById('current-tire-level').innerText = tireLevel;
            document.getElementById('current-tire-perf').innerText = tireConfig.getSteering(tireLevel).toFixed(3);
            if (tireLevel < tireConfig.maxLevel) {
                btnTire.innerText = `å‡çº§ (Lv.${nextTireLevel}) (èŠ±è´¹: ${tireConfig.getCost(nextTireLevel)})`;
                btnTire.disabled = false;
            } else {
                btnTire.innerText = "å·²è¾¾æœ€é«˜ç­‰çº§";
                btnTire.disabled = true;
            }
        }

        window.game.upgradePart = function(partName) {
            let car = playerData.cars[0];
            let config = CAR_CONFIG[partName];
            let partKey = partName === 'engine' ? 'engineLevel' : 'tireLevel';
            
            if (car[partKey] >= config.maxLevel) {
                document.getElementById('upgrade-message').innerText = `${partName} å·²è¾¾æœ€é«˜ç­‰çº§!`;
                return;
            }
            
            const nextLevel = car[partKey] + 1;
            const upgradeCost = config.getCost(nextLevel);

            if (playerData.credits >= upgradeCost) {
                playerData.credits -= upgradeCost;
                car[partKey] = nextLevel;
                savePlayerData();
                document.getElementById('upgrade-message').style.color = 'green';
                document.getElementById('upgrade-message').innerText = `${partName} å‡çº§æˆåŠŸ! è´¹ç”¨: ${upgradeCost}ã€‚`;
            } else {
                document.getElementById('upgrade-message').style.color = 'red';
                document.getElementById('upgrade-message').innerText = `é‡‘å¸ä¸è¶³! éœ€è¦ ${upgradeCost}ã€‚`;
            }
        }


        // --- æ¯”èµ›é€»è¾‘ ---

        function updateRaceUI() {
            document.getElementById('my-lap-count').innerText = `${myRaceState.lap} / ${MAX_LAPS}`;
            document.getElementById('my-checkpoint').innerText = myRaceState.label;
            
            const remoteDisplay = remoteCar ? `${remoteRaceState.lap}` : 'N/A';
            document.getElementById('remote-lap-count').innerText = remoteDisplay;
            
            let statusText = 'æœªå¼€å§‹';
            if (raceActive) {
                statusText = isSinglePlayerMode ? 'è¿›è¡Œä¸­ (äººæœºæ¨¡å¼)' : (isHost ? 'è¿›è¡Œä¸­ (æˆ¿ä¸»)' : 'è¿›è¡Œä¸­ (å®¢æˆ·ç«¯)');
            }
            document.getElementById('race-active-status').innerText = statusText;
            
            // æ¨¡å¼ç›¸å…³çš„ UI æç¤ºå’Œæ ‡ç­¾
            document.getElementById('remote-player-label').innerText = isSinglePlayerMode ? 'AI' : 'å¯¹æ‰‹';
            document.getElementById('game-status-label').innerText = isSinglePlayerMode ? 'AI çŠ¶æ€ / æ¯”èµ›æ—¥å¿—:' : 'P2P åŒæ­¥çŠ¶æ€ / æ¯”èµ›æ—¥å¿—:';
            document.getElementById('start-race-button').innerText = isSinglePlayerMode ? 'å¼€å§‹æ¯”èµ› (äººæœº)' : 'å¼€å§‹æ¯”èµ› (æˆ¿ä¸»)';
        }

        function handleCollision(event) {
            if (!raceActive || myRaceState.finished) return;

            const pairs = event.pairs;

            pairs.forEach(pair => {
                let checkpointBody;
                if ((pair.bodyA.label === 'MyCar' && pair.bodyB.label.startsWith('CP')) || 
                    (pair.bodyB.label === 'MyCar' && pair.bodyA.label.startsWith('CP'))) {
                    checkpointBody = pair.bodyA.label.startsWith('CP') ? pair.bodyA : pair.bodyB;
                    
                    const checkpointIndex = checkpointBody.index;

                    if (checkpointIndex === myRaceState.nextCheckpoint) {
                        if (checkpointBody.label === 'Finish Line' && myRaceState.nextCheckpoint === CHECKPOINTS.length) { 
                            myRaceState.lap++;
                            myRaceState.nextCheckpoint = 1; 
                        } else if (checkpointBody.label !== 'Finish Line') {
                            myRaceState.nextCheckpoint++;
                        } else if (checkpointBody.label === 'Finish Line' && myRaceState.nextCheckpoint !== CHECKPOINTS.length) {
                            return;
                        }
                        
                        myRaceState.label = checkpointBody.label;
                        updateRaceUI();
                        
                        if (!isSinglePlayerMode) {
                            sendRaceStateUpdate(); 
                        }
                        
                        if (myRaceState.lap >= MAX_LAPS) {
                            finishRace(true); 
                        }
                    } 
                }
            });
        }

        window.game.startRace = function() {
            if (!peer || !peer.id) return alert("è¯·å…ˆåˆå§‹åŒ– PeerJSã€‚");
            
            isHost = true; 
            myRaceState = { ...initialRaceState };
            remoteRaceState = { ...initialRaceState };
            raceActive = true;
            myRaceState.finishTime = null; 
            remoteRaceState.finishTime = null;
            updateUI(); 

            if (isSinglePlayerMode) {
                addRemoteCar(100, 150); 
            } else {
                if (!connection || !connection.open) {
                    return alert("å½“å‰æ˜¯å¤šäººæ¨¡å¼ï¼Œè¯·å…ˆè¿æ¥åˆ°å¯¹æ‰‹ã€‚");
                }
                connection.send({ type: 'race_start' });
            }
            
            document.getElementById('start-race-button').disabled = true;
            document.getElementById('game-status-log').innerHTML = "æ¯”èµ›å¼€å§‹!";
        }

        function finishRace(isMyCar) {
            if (!raceActive) return;
            
            const state = isMyCar ? myRaceState : remoteRaceState;
            if (state.finished) return; 
            
            state.finished = true;
            state.finishTime = Date.now();
            
            if (isMyCar && !isSinglePlayerMode) sendRaceStateUpdate(); 

            if (isHost) {
                const remoteFinished = !remoteCar || remoteRaceState.finished;
                if (myRaceState.finished && remoteFinished) {
                    const myCarWon = !remoteCar || (myRaceState.finishTime < remoteRaceState.finishTime);
                    hostSettleRace(myCarWon);
                }
            }
        }

        function hostSettleRace(myCarWon) {
            if (!isHost) return;
            
            const reward = myCarWon ? 3000 : 1000;
            const resultMessage = myCarWon ? "æ­å–œï¼Œä½ èµ¢äº†æ¯”èµ›!" : "ä½ è¾“äº†ï¼Œä½†è·å¾—å®‰æ…°å¥–ã€‚";
            
            if (!isSinglePlayerMode && connection && connection.open) {
                const remoteReward = myCarWon ? 1000 : 3000;
                connection.send({ type: 'settlement', credits_awarded: remoteReward, message: remoteReward > 1000 ? "ä½ èµ¢å¾—äº†æ¯”èµ›!" : "ä½ è¾“äº†æ¯”èµ›ã€‚" });
            }
            
            window.game.addCredits(reward);
            document.getElementById('upgrade-message').style.color = 'green';
            document.getElementById('upgrade-message').innerText = `${resultMessage} å¥–åŠ±: ${reward} é‡‘å¸ã€‚`;
            document.getElementById('game-status-log').innerHTML = `æ¯”èµ›ç»“æŸ! ${resultMessage}`;
            
            raceActive = false;
            document.getElementById('start-race-button').disabled = false;
            updateUI();
        }


        // --- PeerJS & è”æœºé€»è¾‘ ---

        function initializePeer() {
            // Note: PeerJS initialization is always needed even for AI mode as it sets up the ID.
            peer = new Peer({ debug: 2 }); 

            peer.on('open', (id) => {
                document.getElementById('my-peer-id').innerText = id;
                document.getElementById('my-peer-id').className = 'status-badge status-connected';
                initPhysics(playerData.cars[0]);
                
                setInterval(sendGameState, 1000 / 30);
                
                if (botInterval) clearInterval(botInterval);
                botInterval = setInterval(runBotLogic, 1000 / 60); 
            });

            peer.on('connection', (conn) => {
                if (isSinglePlayerMode) { conn.close(); return; }
                connection = conn;
                setupConnectionListeners(conn);
            });
        }

        window.game.connectToPeer = function() {
            if (isSinglePlayerMode) return alert("å½“å‰æ˜¯å•æœºäººæœºæ¨¡å¼ï¼Œè¯·å…ˆåˆ‡æ¢åˆ°å¤šäººè”æœºã€‚");
            const remoteId = document.getElementById('remote-id').value;
            if (!remoteId) return alert('è¯·è¾“å…¥å¯¹æ–¹çš„ Peer ID');
            connection = peer.connect(remoteId);
            setupConnectionListeners(connection);
        }

        function setupConnectionListeners(conn) {
            const statusDisplay = document.getElementById('connection-status');
            
            conn.on('open', () => {
                statusDisplay.innerText = 'å·²è¿æ¥';
                statusDisplay.className = 'status-badge status-connected';
                const myCar = getMyCar();
                conn.send({ type: 'config', config: playerData.cars[0], x: myCar.position.x, y: myCar.position.y });
                
                if (!remoteCar) { addRemoteCar(400, 200); }
            });

            conn.on('data', handleReceivedData);
            conn.on('close', () => {
                statusDisplay.innerText = 'å·²æ–­å¼€';
                statusDisplay.className = 'status-badge status-disconnected';
                removeRemoteCar();
            });
        }

        function sendGameState() {
            const myCar = getMyCar();
            if (!isSinglePlayerMode && connection && connection.open && myCar) {
                const state = { type: 'position', x: myCar.position.x, y: myCar.position.y, a: myCar.angle };
                connection.send(state);
            }
        }

        function sendRaceStateUpdate() {
            if (!isSinglePlayerMode && connection && connection.open) {
                connection.send({ type: 'race_state', lap: myRaceState.lap, nextCp: myRaceState.nextCheckpoint, label: myRaceState.label, finished: myRaceState.finished });
            }
        }

        function handleReceivedData(data) {
            if (isSinglePlayerMode) return; 
            
            const log = document.getElementById('messages-log');
            const entry = document.createElement('p');
            
            if (data.type === 'chat') { entry.innerHTML = `**[å¯¹æ‰‹æ¶ˆæ¯]** æ”¶åˆ°: ${data.message}`; } 
            else if (data.type === 'position') {
                updateRemoteCar(data.x, data.y, data.a);
                document.getElementById('game-status-log').innerHTML = `**[P2PåŒæ­¥]** å¯¹æ–¹ä½ç½®: (X:${data.x.toFixed(0)}, Y:${data.y.toFixed(0)})`;
                return; 
            } else if (data.type === 'config') {
                updateRemoteCar(data.x, data.y, 0); 
                entry.innerHTML = `**[é…ç½®åŒæ­¥]** æ”¶åˆ°èµ›è½¦é…ç½®: å¼•æ“ Lv.${data.config.engineLevel}ã€‚`;
            } else if (data.type === 'race_start') {
                isHost = false; raceActive = true; myRaceState = { ...initialRaceState }; remoteRaceState = { ...initialRaceState }; updateUI();
                document.getElementById('start-race-button').disabled = true;
                entry.innerHTML = `**[æ¯”èµ›é€šçŸ¥]** ä¸»æœºå¼€å§‹äº†æ¯”èµ›!`;
            } else if (data.type === 'race_state') {
                remoteRaceState.lap = data.lap; remoteRaceState.nextCheckpoint = data.nextCp; remoteRaceState.label = data.label;
                if (data.finished && !remoteRaceState.finished) finishRace(false);
                updateRaceUI();
                return; 
            } else if (data.type === 'settlement') {
                window.game.addCredits(data.credits_awarded); 
                document.getElementById('upgrade-message').style.color = 'green';
                document.getElementById('upgrade-message').innerText = `æ”¶åˆ°æ¯”èµ›ç»“ç®—: ${data.message} å¥–åŠ±: ${data.credits_awarded} é‡‘å¸ã€‚`;
                raceActive = false;
                document.getElementById('start-race-button').disabled = false;
                updateUI();
            } else { entry.innerHTML = `**[æœªçŸ¥æ•°æ®]** ${JSON.stringify(data)}`; }
            
            log.prepend(entry);
        }
        
        window.game.sendMessage = function() {
            if (isSinglePlayerMode) return alert("å•æœºæ¨¡å¼æ— æ³•å‘é€æ¶ˆæ¯!");
            const input = document.getElementById('message-input');
            const message = input.value;
            if (!connection || connection.open === false) return alert('å°šæœªå»ºç«‹è¿æ¥!');
            if (message) {
                connection.send({ type: 'chat', message: message });
                input.value = '';
                const log = document.getElementById('messages-log');
                const entry = document.createElement('p');
                entry.innerHTML = `**[è‡ªå·±]** å‘é€: ${message}`;
                log.prepend(entry);
            }
        }
        
        window.game.toggleSinglePlayer = function(isSingle) {
            isSinglePlayerMode = isSingle;
            
            // æ ¸å¿ƒéšè—é€»è¾‘
            const controlsDiv = document.getElementById('controls');
            if (isSingle) {
                controlsDiv.classList.add('hidden');
                // æ¸…ç©º P2P çŠ¶æ€æ—¥å¿—
                document.getElementById('messages-log').innerHTML = '';
            } else {
                controlsDiv.classList.remove('hidden');
            }
            
            // é‡ç½®çŠ¶æ€å’Œ UI
            removeRemoteCar();
            myRaceState = { ...initialRaceState };
            remoteRaceState = { ...initialRaceState };
            raceActive = false;
            updateUI();
            
            document.getElementById('start-race-button').disabled = false;
            
            if (connection) {
                 connection.close(); 
                 connection = null;
                 document.getElementById('connection-status').innerText = 'æ–­å¼€';
                 document.getElementById('connection-status').className = 'status-badge status-disconnected';
            }
        }


        // --- ç§»åŠ¨ç«¯é€‚é…å’Œäº‹ä»¶ç›‘å¬ (ä¿æŒä¸å˜) ---

        function handleTouch(key, isDown) {
            const stateKey = key.toUpperCase();
            if (KEY_STATE.hasOwnProperty(stateKey)) {
                KEY_STATE[stateKey] = isDown;
            }
        }

        function setupTouchControls() {
            const controls = [
                { id: 'btn-up', key: 'UP' }, { id: 'btn-down', key: 'DOWN' },
                { id: 'btn-left', key: 'LEFT' }, { id: 'btn-right', key: 'RIGHT' }
            ];

            controls.forEach(control => {
                const btn = document.getElementById(control.id);
                if (btn) {
                    btn.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch(control.key, true); });
                    btn.addEventListener('touchend', (e) => { e.preventDefault(); handleTouch(control.key, false); });
                    btn.addEventListener('mousedown', (e) => { e.preventDefault(); handleTouch(control.key, true); });
                    btn.addEventListener('mouseup', (e) => { e.preventDefault(); handleTouch(control.key, false); });
                    btn.addEventListener('mouseleave', () => { if (KEY_STATE[control.key]) handleTouch(control.key, false); });
                }
            });
        }

        function setupKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                if (event.key === 'w' || event.key === 'W') KEY_STATE.UP = true;
                if (event.key === 's' || event.key === 'S') KEY_STATE.DOWN = true;
                if (event.key === 'a' || event.key === 'A') KEY_STATE.LEFT = true;
                if (event.key === 'd' || event.key === 'D') KEY_STATE.RIGHT = true;
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === 'w' || event.key === 'W') KEY_STATE.UP = false;
                if (event.key === 's' || event.key === 'S') KEY_STATE.DOWN = false;
                if (event.key === 'a' || event.key === 'A') KEY_STATE.LEFT = false;
                if (event.key === 'd' || event.key === 'D') KEY_STATE.RIGHT = false;
            });
        }


        // --- å¯åŠ¨æµç¨‹ ---

        window.game = window.game || {}; 
        Object.assign(window.game, {
            saveTestData: window.game.saveTestData,
            addCredits: window.game.addCredits,
            upgradePart: window.game.upgradePart,
            connectToPeer: window.game.connectToPeer,
            sendMessage: window.game.sendMessage,
            startRace: window.game.startRace,
            toggleSinglePlayer: window.game.toggleSinglePlayer 
        });


        document.addEventListener('DOMContentLoaded', () => {
            loadPlayerData();
            initializePeer();
            setupTouchControls();
            setupKeyboardControls();
        });
    </script>
</body>
</html>
